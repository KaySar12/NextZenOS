// Package codegen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package codegen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Access_tokenScopes = "access_token.Scopes"
)

// Defines values for SetZerotierNetworkStatusJSONBodyStatus.
const (
	Offline SetZerotierNetworkStatusJSONBodyStatus = "offline"
	Online  SetZerotierNetworkStatusJSONBodyStatus = "online"
)

// BaseResponse defines model for BaseResponse.
type BaseResponse struct {
	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// HealthPorts defines model for HealthPorts.
type HealthPorts struct {
	TCP *[]int `json:"tcp,omitempty"`
	UDP *[]int `json:"udp,omitempty"`
}

// HealthServices defines model for HealthServices.
type HealthServices struct {
	NotRunning *[]string `json:"not_running,omitempty"`
	Running    *[]string `json:"running,omitempty"`
}

// SuccessResponseString defines model for SuccessResponseString.
type SuccessResponseString struct {
	// Data When the interface returns success, this field is the specific success information
	Data *string `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// ZTInfo defines model for ZTInfo.
type ZTInfo struct {
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Status *string `json:"status,omitempty"`
}

// GetHealthPortsOK defines model for GetHealthPortsOK.
type GetHealthPortsOK struct {
	Data *HealthPorts `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// GetHealthServicesOK defines model for GetHealthServicesOK.
type GetHealthServicesOK struct {
	Data *HealthServices `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// GetZTInfoOK defines model for GetZTInfoOK.
type GetZTInfoOK = ZTInfo

// ResponseClientError defines model for ResponseClientError.
type ResponseClientError = BaseResponse

// ResponseInternalServerError defines model for ResponseInternalServerError.
type ResponseInternalServerError = BaseResponse

// ResponseOK defines model for ResponseOK.
type ResponseOK = BaseResponse

// ResponseStringOK defines model for ResponseStringOK.
type ResponseStringOK = SuccessResponseString

// CheckUploadChunkParams defines parameters for CheckUploadChunk.
type CheckUploadChunkParams struct {
	// Path File path
	Path string `form:"path" json:"path"`

	// RelativePath File path
	RelativePath string `form:"relativePath" json:"relativePath"`

	// Filename File name
	Filename string `form:"filename" json:"filename"`

	// ChunkNumber chunk number
	ChunkNumber string `form:"chunkNumber" json:"chunkNumber"`

	// TotalChunks total chunks
	TotalChunks int `form:"totalChunks" json:"totalChunks"`
}

// PostUploadFileMultipartBody defines parameters for PostUploadFile.
type PostUploadFileMultipartBody struct {
	ChunkNumber      *string             `json:"chunkNumber,omitempty"`
	ChunkSize        *string             `json:"chunkSize,omitempty"`
	CurrentChunkSize *string             `json:"currentChunkSize,omitempty"`
	File             *openapi_types.File `json:"file,omitempty"`
	Filename         *string             `json:"filename,omitempty"`
	Identifier       *string             `json:"identifier,omitempty"`
	Path             *string             `json:"path,omitempty"`
	RelativePath     *string             `json:"relativePath,omitempty"`
	TotalChunks      *string             `json:"totalChunks,omitempty"`
	TotalSize        *string             `json:"totalSize,omitempty"`
}

// SetZerotierNetworkStatusJSONBody defines parameters for SetZerotierNetworkStatus.
type SetZerotierNetworkStatusJSONBody struct {
	Status *SetZerotierNetworkStatusJSONBodyStatus `json:"status,omitempty"`
}

// SetZerotierNetworkStatusJSONBodyStatus defines parameters for SetZerotierNetworkStatus.
type SetZerotierNetworkStatusJSONBodyStatus string

// PostUploadFileMultipartRequestBody defines body for PostUploadFile for multipart/form-data ContentType.
type PostUploadFileMultipartRequestBody PostUploadFileMultipartBody

// SetZerotierNetworkStatusJSONRequestBody defines body for SetZerotierNetworkStatus for application/json ContentType.
type SetZerotierNetworkStatusJSONRequestBody SetZerotierNetworkStatusJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Test file methods
	// (GET /file/test)
	GetFileTest(ctx echo.Context) error
	// Check upload chunk
	// (GET /file/upload)
	CheckUploadChunk(ctx echo.Context, params CheckUploadChunkParams) error
	// Upload file
	// (POST /file/upload)
	PostUploadFile(ctx echo.Context) error
	// Get log
	// (GET /health/logs)
	GetHealthlogs(ctx echo.Context) error
	// Get port in use
	// (GET /health/ports)
	GetHealthPorts(ctx echo.Context) error
	// Get service status
	// (GET /health/services)
	GetHealthServices(ctx echo.Context) error
	// Get Zerotier info
	// (GET /zt/info)
	GetZerotierInfo(ctx echo.Context) error
	// Set Zerotier network status
	// (PUT /zt/{network_id}/status)
	SetZerotierNetworkStatus(ctx echo.Context, networkId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetFileTest converts echo context to params.
func (w *ServerInterfaceWrapper) GetFileTest(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFileTest(ctx)
	return err
}

// CheckUploadChunk converts echo context to params.
func (w *ServerInterfaceWrapper) CheckUploadChunk(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckUploadChunkParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Required query parameter "relativePath" -------------

	err = runtime.BindQueryParameter("form", true, true, "relativePath", ctx.QueryParams(), &params.RelativePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter relativePath: %s", err))
	}

	// ------------- Required query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, true, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Required query parameter "chunkNumber" -------------

	err = runtime.BindQueryParameter("form", true, true, "chunkNumber", ctx.QueryParams(), &params.ChunkNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chunkNumber: %s", err))
	}

	// ------------- Required query parameter "totalChunks" -------------

	err = runtime.BindQueryParameter("form", true, true, "totalChunks", ctx.QueryParams(), &params.TotalChunks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter totalChunks: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckUploadChunk(ctx, params)
	return err
}

// PostUploadFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostUploadFile(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUploadFile(ctx)
	return err
}

// GetHealthlogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthlogs(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthlogs(ctx)
	return err
}

// GetHealthPorts converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthPorts(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthPorts(ctx)
	return err
}

// GetHealthServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthServices(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthServices(ctx)
	return err
}

// GetZerotierInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetZerotierInfo(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetZerotierInfo(ctx)
	return err
}

// SetZerotierNetworkStatus converts echo context to params.
func (w *ServerInterfaceWrapper) SetZerotierNetworkStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network_id" -------------
	var networkId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "network_id", runtime.ParamLocationPath, ctx.Param("network_id"), &networkId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetZerotierNetworkStatus(ctx, networkId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/file/test", wrapper.GetFileTest)
	router.GET(baseURL+"/file/upload", wrapper.CheckUploadChunk)
	router.POST(baseURL+"/file/upload", wrapper.PostUploadFile)
	router.GET(baseURL+"/health/logs", wrapper.GetHealthlogs)
	router.GET(baseURL+"/health/ports", wrapper.GetHealthPorts)
	router.GET(baseURL+"/health/services", wrapper.GetHealthServices)
	router.GET(baseURL+"/zt/info", wrapper.GetZerotierInfo)
	router.PUT(baseURL+"/zt/:network_id/status", wrapper.SetZerotierNetworkStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
