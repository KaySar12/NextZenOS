// Package codegen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package codegen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	Access_tokenScopes = "access_token.Scopes"
)

// Defines values for SetZerotierNetworkStatusJSONBodyStatus.
const (
	Offline SetZerotierNetworkStatusJSONBodyStatus = "offline"
	Online  SetZerotierNetworkStatusJSONBodyStatus = "online"
)

// BaseResponse defines model for BaseResponse.
type BaseResponse struct {
	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// HealthPorts defines model for HealthPorts.
type HealthPorts struct {
	TCP *[]int `json:"tcp,omitempty"`
	UDP *[]int `json:"udp,omitempty"`
}

// HealthServices defines model for HealthServices.
type HealthServices struct {
	NotRunning *[]string `json:"not_running,omitempty"`
	Running    *[]string `json:"running,omitempty"`
}

// SuccessResponseString defines model for SuccessResponseString.
type SuccessResponseString struct {
	// Data When the interface returns success, this field is the specific success information
	Data *string `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// ZTInfo defines model for ZTInfo.
type ZTInfo struct {
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Status *string `json:"status,omitempty"`
}

// GetHealthPortsOK defines model for GetHealthPortsOK.
type GetHealthPortsOK struct {
	Data *HealthPorts `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// GetHealthServicesOK defines model for GetHealthServicesOK.
type GetHealthServicesOK struct {
	Data *HealthServices `json:"data,omitempty"`

	// Message message returned by server side if there is any
	Message *string `json:"message,omitempty"`
}

// GetZTInfoOK defines model for GetZTInfoOK.
type GetZTInfoOK = ZTInfo

// ResponseClientError defines model for ResponseClientError.
type ResponseClientError = BaseResponse

// ResponseInternalServerError defines model for ResponseInternalServerError.
type ResponseInternalServerError = BaseResponse

// ResponseOK defines model for ResponseOK.
type ResponseOK = BaseResponse

// ResponseStringOK defines model for ResponseStringOK.
type ResponseStringOK = SuccessResponseString

// CheckUploadChunkParams defines parameters for CheckUploadChunk.
type CheckUploadChunkParams struct {
	// Path File path
	Path string `form:"path" json:"path"`

	// RelativePath File path
	RelativePath string `form:"relativePath" json:"relativePath"`

	// Filename File name
	Filename string `form:"filename" json:"filename"`

	// ChunkNumber chunk number
	ChunkNumber string `form:"chunkNumber" json:"chunkNumber"`

	// TotalChunks total chunks
	TotalChunks int `form:"totalChunks" json:"totalChunks"`
}

// PostUploadFileMultipartBody defines parameters for PostUploadFile.
type PostUploadFileMultipartBody struct {
	ChunkNumber      *string             `json:"chunkNumber,omitempty"`
	ChunkSize        *string             `json:"chunkSize,omitempty"`
	CurrentChunkSize *string             `json:"currentChunkSize,omitempty"`
	File             *openapi_types.File `json:"file,omitempty"`
	Filename         *string             `json:"filename,omitempty"`
	Identifier       *string             `json:"identifier,omitempty"`
	Path             *string             `json:"path,omitempty"`
	RelativePath     *string             `json:"relativePath,omitempty"`
	TotalChunks      *string             `json:"totalChunks,omitempty"`
	TotalSize        *string             `json:"totalSize,omitempty"`
}

// SetZerotierNetworkStatusJSONBody defines parameters for SetZerotierNetworkStatus.
type SetZerotierNetworkStatusJSONBody struct {
	Status *SetZerotierNetworkStatusJSONBodyStatus `json:"status,omitempty"`
}

// SetZerotierNetworkStatusJSONBodyStatus defines parameters for SetZerotierNetworkStatus.
type SetZerotierNetworkStatusJSONBodyStatus string

// PostUploadFileMultipartRequestBody defines body for PostUploadFile for multipart/form-data ContentType.
type PostUploadFileMultipartRequestBody PostUploadFileMultipartBody

// SetZerotierNetworkStatusJSONRequestBody defines body for SetZerotierNetworkStatus for application/json ContentType.
type SetZerotierNetworkStatusJSONRequestBody SetZerotierNetworkStatusJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Test file methods
	// (GET /file/test)
	GetFileTest(ctx echo.Context) error
	// Check upload chunk
	// (GET /file/upload)
	CheckUploadChunk(ctx echo.Context, params CheckUploadChunkParams) error
	// Upload file
	// (POST /file/upload)
	PostUploadFile(ctx echo.Context) error
	// Get log
	// (GET /health/logs)
	GetHealthlogs(ctx echo.Context) error
	// Get port in use
	// (GET /health/ports)
	GetHealthPorts(ctx echo.Context) error
	// Get service status
	// (GET /health/services)
	GetHealthServices(ctx echo.Context) error
	// Get Zerotier info
	// (GET /zt/info)
	GetZerotierInfo(ctx echo.Context) error
	// Set Zerotier network status
	// (PUT /zt/{network_id}/status)
	SetZerotierNetworkStatus(ctx echo.Context, networkId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetFileTest converts echo context to params.
func (w *ServerInterfaceWrapper) GetFileTest(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFileTest(ctx)
	return err
}

// CheckUploadChunk converts echo context to params.
func (w *ServerInterfaceWrapper) CheckUploadChunk(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckUploadChunkParams
	// ------------- Required query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, true, "path", ctx.QueryParams(), &params.Path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	// ------------- Required query parameter "relativePath" -------------

	err = runtime.BindQueryParameter("form", true, true, "relativePath", ctx.QueryParams(), &params.RelativePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter relativePath: %s", err))
	}

	// ------------- Required query parameter "filename" -------------

	err = runtime.BindQueryParameter("form", true, true, "filename", ctx.QueryParams(), &params.Filename)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	// ------------- Required query parameter "chunkNumber" -------------

	err = runtime.BindQueryParameter("form", true, true, "chunkNumber", ctx.QueryParams(), &params.ChunkNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chunkNumber: %s", err))
	}

	// ------------- Required query parameter "totalChunks" -------------

	err = runtime.BindQueryParameter("form", true, true, "totalChunks", ctx.QueryParams(), &params.TotalChunks)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter totalChunks: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckUploadChunk(ctx, params)
	return err
}

// PostUploadFile converts echo context to params.
func (w *ServerInterfaceWrapper) PostUploadFile(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUploadFile(ctx)
	return err
}

// GetHealthlogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthlogs(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthlogs(ctx)
	return err
}

// GetHealthPorts converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthPorts(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthPorts(ctx)
	return err
}

// GetHealthServices converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthServices(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealthServices(ctx)
	return err
}

// GetZerotierInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetZerotierInfo(ctx echo.Context) error {
	var err error

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetZerotierInfo(ctx)
	return err
}

// SetZerotierNetworkStatus converts echo context to params.
func (w *ServerInterfaceWrapper) SetZerotierNetworkStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network_id" -------------
	var networkId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "network_id", runtime.ParamLocationPath, ctx.Param("network_id"), &networkId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network_id: %s", err))
	}

	ctx.Set(Access_tokenScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetZerotierNetworkStatus(ctx, networkId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/file/test", wrapper.GetFileTest)
	router.GET(baseURL+"/file/upload", wrapper.CheckUploadChunk)
	router.POST(baseURL+"/file/upload", wrapper.PostUploadFile)
	router.GET(baseURL+"/health/logs", wrapper.GetHealthlogs)
	router.GET(baseURL+"/health/ports", wrapper.GetHealthPorts)
	router.GET(baseURL+"/health/services", wrapper.GetHealthServices)
	router.GET(baseURL+"/zt/info", wrapper.GetZerotierInfo)
	router.PUT(baseURL+"/zt/:network_id/status", wrapper.SetZerotierNetworkStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAAA//9gcJVT0xwAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
